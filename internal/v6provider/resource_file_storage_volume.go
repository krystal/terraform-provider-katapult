package v6provider

import (
	"context"
	"errors"
	"strings"
	"time"

	"github.com/hashicorp/terraform-plugin-framework-validators/setvalidator"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/tfsdk"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/krystal/go-katapult"
	"github.com/krystal/go-katapult/core"
)

type (
	FileStorageVolumeResource struct {
		M *Meta
	}

	FileStorageVolumeResourceModel struct {
		ID           types.String `tfsdk:"id"`
		Name         types.String `tfsdk:"name"`
		Associations types.Set    `tfsdk:"associations"`
		NFSLocation  types.String `tfsdk:"nfs_location"`
	}
)

func (r FileStorageVolumeResource) Metadata(
	_ context.Context,
	req resource.MetadataRequest,
	resp *resource.MetadataResponse,
) {
	resp.TypeName = req.ProviderTypeName + "_file_storage_volume"
}

func (r *FileStorageVolumeResource) Configure(
	_ context.Context,
	req resource.ConfigureRequest,
	resp *resource.ConfigureResponse,
) {
	if req.ProviderData == nil {
		return
	}

	meta, ok := req.ProviderData.(*Meta)
	if !ok {
		resp.Diagnostics.AddError(
			"Meta Error",
			"meta is not of type *Meta",
		)
		return
	}

	r.M = meta
}

func (r FileStorageVolumeResource) Schema(
	_ context.Context,
	_ resource.SchemaRequest,
	resp *resource.SchemaResponse,
) {
	resp.Schema = schema.Schema{
		Attributes: map[string]schema.Attribute{
			"id": schema.StringAttribute{
				Computed: true,
				MarkdownDescription: "The ID of the file storage volume. " +
					"This is automatically generated by the API.",
			},
			"name": schema.StringAttribute{
				Required: true,
				MarkdownDescription: "Unique name to help " +
					"identify the volume. " +
					"Must be unique within the organization.",
				Validators: []validator.String{
					stringvalidator.LengthAtLeast(1),
				},
			},
			"associations": schema.SetAttribute{
				Optional: true,
				MarkdownDescription: "The resource IDs which can access " +
					"this file storage volume. Currently only accepts " +
					"virtual machine IDs.",
				ElementType: types.StringType,
				Validators: []validator.Set{
					setvalidator.ValueStringsAre(
						stringvalidator.LengthAtLeast(1),
					),
				},
			},
			"nfs_location": schema.StringAttribute{
				Computed: true,
				MarkdownDescription: "The NFS location indicating where " +
					"to mount the volume from. This is where the volume " +
					"must be mounted from inside of virtual machines " +
					"referenced in `associations`.",
			},
		},
	}
}

func (r *FileStorageVolumeResource) Create(
	ctx context.Context,
	req resource.CreateRequest,
	resp *resource.CreateResponse,
) {
	var plan FileStorageVolumeResourceModel

	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
	if resp.Diagnostics.HasError() {
		return
	}

	associations := []string{}
	resp.Diagnostics.Append(
		plan.Associations.ElementsAs(
			ctx,
			&associations,
			false,
		)...)
	if resp.Diagnostics.HasError() {
		return
	}

	args := &core.FileStorageVolumeCreateArguments{
		Name:         plan.Name.ValueString(),
		DataCenter:   r.M.DataCenterRef,
		Associations: associations,
	}

	fsv, _, err := r.M.Core.FileStorageVolumes.Create(
		ctx, r.M.OrganizationRef, args,
	)
	if err != nil {
		resp.Diagnostics.AddError(
			"FileStorageVolumeCreate Error",
			"Error creating file storage volume: "+err.Error(),
		)
		return
	}

	// 20 minutes is the default timeout for the provider
	// 2 seconds is the default delay for the provider
	// The 20 minutes is used as it was the default in SDKv2
	// TODO: look into allowing users to configure this
	fsv, err = waitForFileStorageVolumeToBeReady(
		ctx, r.M, 20*time.Minute, 2*time.Second, fsv.Ref(),
	)

	if err != nil {
		resp.Diagnostics.AddError(
			"Error waiting for file storage "+
				"volume to become ready.",
			err.Error(),
		)
	}

	if err := r.FileStorageVolumeRead(
		ctx,
		fsv.ID,
		&plan,
		&resp.State,
	); err != nil {
		resp.Diagnostics.AddError(
			"FileStorageVolumeRead Error",
			"Error reading file storage volume: "+err.Error(),
		)
		return
	}

	resp.Diagnostics.Append(resp.State.Set(ctx, plan)...)
}

func (r *FileStorageVolumeResource) Read(
	ctx context.Context,
	req resource.ReadRequest,
	resp *resource.ReadResponse,
) {
	state := &FileStorageVolumeResourceModel{}
	diags := req.State.Get(ctx, &state)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	err := r.FileStorageVolumeRead(
		ctx, state.ID.ValueString(), state, &resp.State,
	)
	if err != nil {
		resp.Diagnostics.AddError(
			"FileStorageVolumeRead Error",
			"Error reading file storage volume: "+err.Error(),
		)
	}

	resp.Diagnostics.Append(resp.State.Set(ctx, state)...)
}

func (r *FileStorageVolumeResource) Update(
	ctx context.Context,
	req resource.UpdateRequest,
	resp *resource.UpdateResponse,
) {
	var plan FileStorageVolumeResourceModel

	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
	if resp.Diagnostics.HasError() {
		return
	}

	var state FileStorageVolumeResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)
	if resp.Diagnostics.HasError() {
		return
	}

	ref := core.FileStorageVolumeRef{ID: plan.ID.ValueString()}
	args := &core.FileStorageVolumeUpdateArguments{}

	if !plan.Name.Equal(state.Name) {
		args.Name = plan.Name.ValueString()
	}

	if !plan.Associations.Equal(state.Associations) {
		associations := []string{}
		resp.Diagnostics.Append(
			plan.Associations.ElementsAs(
				ctx,
				&associations,
				false,
			)...)
		if resp.Diagnostics.HasError() {
			return
		}

		args.Associations = &associations
	}

	fsv, _, err := r.M.Core.FileStorageVolumes.Update(ctx, ref, args)
	if err != nil {
		resp.Diagnostics.AddError(
			"FileStorageVolumeUpdate Error",
			"Error updating file storage volume: "+err.Error(),
		)
		return
	}

	_, err = waitForFileStorageVolumeToBeReady(
		ctx,
		r.M,
		20*time.Minute,
		5*time.Second,
		fsv.Ref())
	if err != nil {
		resp.Diagnostics.AddError(
			"Error waiting for file storage "+
				"volume to become ready.",
			err.Error(),
		)
	}

	if err := r.FileStorageVolumeRead(
		ctx,
		fsv.ID,
		&plan,
		&resp.State,
	); err != nil {
		resp.Diagnostics.AddError(
			"FileStorageVolumeRead Error",
			"Error reading file storage volume: "+err.Error(),
		)
		return
	}

	resp.Diagnostics.Append(resp.State.Set(ctx, plan)...)
}

func (r *FileStorageVolumeResource) Delete(
	ctx context.Context,
	req resource.DeleteRequest,
	resp *resource.DeleteResponse,
) {
	var state FileStorageVolumeResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)
	if resp.Diagnostics.HasError() {
		return
	}

	fsv, _, err := r.M.Core.FileStorageVolumes.GetByID(
		ctx,
		state.ID.ValueString())
	if err != nil {
		if errors.Is(err, katapult.ErrNotFound) {
			return
		} else if errors.Is(err, core.ErrObjectInTrash) {
			if r.M.SkipTrashObjectPurge {
				return
			}

			purgeError := purgeTrashObjectByObjectID(
				ctx, r.M, 20*time.Minute, fsv.ID,
			)
			if purgeError != nil {
				resp.Diagnostics.AddError(
					"Failed to purge file storage volume from trash.",
					purgeError.Error(),
				)

				return
			}

			return
		}

		resp.Diagnostics.AddError(
			"Failed to lookup file storage volume details.",
			err.Error(),
		)

		return
	}

	// If we're skipping purge, we rename the file storage volume before
	// deletion to include its ID. This allows it to be easily identified in the
	// trash, and also avoids name conflicts if another volume is created with
	// the same name.
	if r.M.SkipTrashObjectPurge {
		// Append the ID to the end of the name, if it's not already there. If
		// the resulting name would be too long, truncate name to fit once the
		// ID is appended.
		name := fsv.Name
		suffix := "-" + fsv.ID
		if !strings.HasSuffix(name, suffix) {
			if len(name)+len(suffix) > 128 {
				name = name[:128-len(suffix)]
			}
			name += suffix
		}

		_, _, err = r.M.Core.FileStorageVolumes.Update(
			ctx, fsv.Ref(),
			&core.FileStorageVolumeUpdateArguments{Name: name},
		)

		if err != nil && !isErrNotFoundOrInTrash(err) {
			resp.Diagnostics.AddError("Failed to rename file storage "+
				"volume before moving to trash.",
				err.Error())

			return
		}
	}

	_, _, _, err = r.M.Core.FileStorageVolumes.Delete(ctx, fsv.Ref())
	if err != nil && !isErrNotFoundOrInTrash(err) {
		resp.Diagnostics.AddError("FileStorageVolumeDelete Error", err.Error())
		return
	}

	if !r.M.SkipTrashObjectPurge {
		err = purgeTrashObjectByObjectID(
			ctx, r.M, 20*time.Minute, fsv.ID,
		)
		if err != nil {
			resp.Diagnostics.AddError(
				"Failed to purge file storage volume from trash.",
				err.Error(),
			)
			return
		}
	}
}

func (r *FileStorageVolumeResource) ImportState(
	ctx context.Context,
	req resource.ImportStateRequest,
	resp *resource.ImportStateResponse,
) {
	resource.ImportStatePassthroughID(ctx, path.Root("id"), req, resp)
}

func (r *FileStorageVolumeResource) FileStorageVolumeRead(
	ctx context.Context,
	id string,
	model *FileStorageVolumeResourceModel,
	state *tfsdk.State,
) error {
	fsv, _, err := r.M.Core.FileStorageVolumes.GetByID(ctx, id)
	if err != nil {
		if errors.Is(err, katapult.ErrNotFound) {
			state.RemoveResource(ctx)

			return nil
		}

		return err
	}

	model.ID = types.StringValue(fsv.ID)
	model.Name = types.StringValue(fsv.Name)
	model.NFSLocation = types.StringValue(fsv.NFSLocation)

	if len(fsv.Associations) > 0 {
		associations := []attr.Value{}
		for _, a := range fsv.Associations {
			associations = append(associations, types.StringValue(a))
		}

		model.Associations = types.SetValueMust(types.StringType, associations)
	}

	return nil
}

// Helper

func waitForFileStorageVolumeToBeReady(
	ctx context.Context,
	m *Meta,
	timeout time.Duration,
	delay time.Duration,
	ref core.FileStorageVolumeRef,
) (*core.FileStorageVolume, error) {
	waiter := &Waiter{
		Pending: []string{
			string(core.FileStorageVolumePending),
			string(core.FileStorageVolumeConfiguring),
		},
		Target: []string{
			string(core.FileStorageVolumeReady),
		},
		Refresh: func() (interface{}, string, error) {
			f, _, err := m.Core.FileStorageVolumes.Get(ctx, ref)
			if err != nil {
				return f, "", err
			}

			return f, string(f.State), nil
		},
		Timeout:                   timeout,
		Delay:                     delay,
		MinTimeout:                5 * time.Second,
		ContinuousTargetOccurence: 1,
	}

	readyFSV, err := waiter.WaitForStateContext(ctx)

	return readyFSV.(*core.FileStorageVolume), err
}
